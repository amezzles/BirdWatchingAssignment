<!DOCTYPE html>
<html>
<head>
    <title>Bird Watching Game</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Monospace; background-color: #000; color: #fff; }
        canvas { width: 100%; height: 100%; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; }
		#controls {
            position: absolute;
            top: 60px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
        button, input[type="range"] {
            margin: 5px;
            padding: 5px;
        }
        label {
            margin-top: 5px;
            display: block;
        }
    </style>
</head>
<!-- 
	<img src="./jsm/images/cameraUI.png" class="responsive" id="image" style="width: 200px; height: 150px;">
	<button onclick="changeImage()">Take Photo</button> -->
<body>
    <div id="info">
        <p>Take photos of birds<br>Use WASD or arrow keys to move the camera, scroll to zoom in/out</p>
    </div>
	<div id="controls">
        <label>Number of Large Trees: <span id="numLargeTreesLabel">10</span></label>
        <input type="range" id="numLargeTrees" min="0" max="500" value="300">

        <label>Spacing Between Large Trees: <span id="spacingLargeTreesLabel">8</span></label>
        <input type="range" id="spacingLargeTrees" min="1" max="50" value="8">

        <label>Number of Small Trees: <span id="numSmallTreesLabel">10</span></label>
        <input type="range" id="numSmallTrees" min="0" max="500" value="100">

        <label>Spacing Between Small Trees: <span id="spacingSmallTreesLabel">10</span></label>
        <input type="range" id="spacingSmallTrees" min="1" max="50" value="10">

        <button id="generateTrees">Generate Trees</button>

        <button id="clearScene">Clear Scene</button>
    </div>
	<script type="importmap">
		{
		  "imports": {
			"three": "../build/three.module.js"
		  }
		}
	  </script>

    <script type="module">
        import * as THREE from 'three';
        import { MTLLoader } from './jsm/loaders/MTLLoader.js';
        import { OBJLoader } from './jsm/loaders/OBJLoader.js';
        import { FirstPersonControls } from './jsm/controls/FirstPersonControls.js';
        import TerrainGenerator from './TerrainGenerator.js';
		import Bird from './Bird.js';
		import Camera from './Camera.js';

        var scene = new THREE.Scene();
		scene.background = new THREE.Color(0x8FBCD4); // Light blue background

		var ratio = window.innerWidth / window.innerHeight;
		var camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);
		camera.position.set(0, 10, 0);
		camera.lookAt(new THREE.Vector3(0, 11, 10));

		var renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.outputEncoding = THREE.sRGBEncoding;
		renderer.gammaOutput = true;
		renderer.gammaFactor = 2.2;
		renderer.physicallyCorrectLights = true;
		renderer.toneMapping = THREE.ACESFilmicToneMapping;
		renderer.toneMappingExposure = 1.0; // Adjust as needed
		
		//renderer.shadowMap.enabled = true;
		//renderer.shadowMap.type = THREE.PCFSoftShadowMap;


		document.body.appendChild(renderer.domElement);

		// Lighting
		var ambientLight = new THREE.AmbientLight(0xf7b9a1, 0.3);
		scene.add(ambientLight);

		var directionalLight1 = new THREE.DirectionalLight(0xEE9B31, 0.4);
		directionalLight1.position.set(0, 0.2, -1);
		directionalLight1.castShadow = true;
		scene.add(directionalLight1);

		var directionalLight2 = new THREE.DirectionalLight(0xFF4B2B,0.4);
		directionalLight2.position.set(0, 6, -10);
		directionalLight2.castShadow = true;
		scene.add(directionalLight2);

		var directionalLight3 = new THREE.DirectionalLight(0xFFDB25, 0.4);
		directionalLight3.position.set(0, 0.2, -10);
		directionalLight3.castShadow = true;
		scene.add(directionalLight3);

		//sky
		const vertexShader = `
			varying vec3 vWorldPosition;

			void main() {
				vec4 worldPosition = modelMatrix * vec4(position, 1.0);
				vWorldPosition = worldPosition.xyz;
				gl_Position = projectionMatrix * viewMatrix * worldPosition;
			}
		`;

		// Fragment Shader
		const fragmentShader = `
			varying vec3 vWorldPosition;

			void main() {
				float height = normalize(vWorldPosition).y;
				vec3 topColor = vec3(0.0, 0.3, 0.6); // Blue
				vec3 bottomColor = vec3(1.0, 0.65, 0.54); // Orange
				gl_FragColor = vec4(mix(bottomColor, topColor, max(height, 0.0)), 1.0);
			}
		`;

		// Create a large sphere geometry
		const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
		const skyMaterial = new THREE.ShaderMaterial({
			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			side: THREE.BackSide
		});

		const sky = new THREE.Mesh(skyGeometry, skyMaterial);
		scene.add(sky);

		//ground
		const loader = new THREE.TextureLoader();
		const grassTexture = loader.load('Assets/grass_texture.jpg');

		grassTexture.wrapS = THREE.RepeatWrapping;
		grassTexture.wrapT = THREE.RepeatWrapping;

		grassTexture.repeat.set(8, 8); // Slightly increase repeat to overlap

		grassTexture.minFilter = THREE.LinearMipMapLinearFilter;
		grassTexture.magFilter = THREE.LinearFilter;

		const groundGeometry = new THREE.PlaneGeometry(500, 500);
		const groundMaterial = new THREE.MeshStandardMaterial({
			normalMap: grassTexture,
			side: THREE.DoubleSide,
			color: 0x88cc54,
			roughness: 0.9,
			metalness: 0.0,
		});

		groundMaterial.normalScale = new THREE.Vector2(2, 2);

		const ground = new THREE.Mesh(groundGeometry, groundMaterial);
		ground.rotation.x = -Math.PI / 2;
		//ground.receiveShadow = true;
		scene.add(ground);

        // Terrain generation
        const terrainGenerator = new TerrainGenerator(scene);
        terrainGenerator.init();

		// Update labels on range input change
		function updateLabel(inputId, labelId) {
			const input = document.getElementById(inputId);
			const label = document.getElementById(labelId);
			label.textContent = input.value;
			input.addEventListener('input', () => {
				label.textContent = input.value;
			});
		}

		updateLabel('numLargeTrees', 'numLargeTreesLabel');
		updateLabel('spacingLargeTrees', 'spacingLargeTreesLabel');
		updateLabel('numSmallTrees', 'numSmallTreesLabel');
		updateLabel('spacingSmallTrees', 'spacingSmallTreesLabel');

		// Generate terrain objects
		async function generateTrees() {
			const numLargeTrees = parseInt(document.getElementById('numLargeTrees').value);
			const spacingLarge = parseInt(document.getElementById('spacingLargeTrees').value);
			const numSmallTrees = parseInt(document.getElementById('numSmallTrees').value);
			const spacingSmall = parseInt(document.getElementById('spacingSmallTrees').value);

			terrainGenerator.generateTrees(numLargeTrees, spacingLarge, numSmallTrees, spacingSmall);
		}

		document.getElementById('generateTrees').addEventListener('click', generateTrees);
		document.getElementById('clearScene').addEventListener('click', () => terrainGenerator.clearTrees());

		//add and move birds
		function getRandomPositionAndDirection() {
			const side = Math.random() > 0.5 ? 'left' : 'right';
			const x = side === 'left' ? -50 : 50;  // Adjust starting x based on the side
			const y = 30;  // Start below the treeline
			const z = 70 + Math.random() * 20;  // Ensure they start behind the treeline
			const direction = side === 'left' ? 1 : -1;  // Rightward if starting from left, leftward if from right
			return { x, y, z, direction };
		}

		const birds = [];
		const spawnInterval = 3000;

		setInterval(() => {
			const { x, y, z, direction } = getRandomPositionAndDirection();
			const newBird = new Bird('bird', x, y, z, direction, scene);
			birds.push(newBird);

			// Optional: Manage bird population
			if (birds.length > 20) {
				const oldBird = birds.shift();
				oldBird.hide();
				scene.remove(oldBird.mesh);
			}
		}, spawnInterval);

		//controls
        const fpControls = new FirstPersonControls(camera, renderer.domElement);
        fpControls.movementSpeed = 1;
        fpControls.lookSpeed = 4;

		//animation
        function animate() {
            requestAnimationFrame(animate);

			//animate birds
			birds.forEach(bird => {
				bird.move();
				if (bird.angle > Math.PI) {  // Conditions to hide and remove birds
					bird.hide();
					scene.remove(bird.mesh);
				}
			});

			renderer.render(scene, camera);
			fpControls.update(0.05);
		}

        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
