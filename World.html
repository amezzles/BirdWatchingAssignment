<html>
  <head>
    <title>Bird Watching Game</title>
  </head>

  <style>
    body { margin: 0; }
    canvas { width: 100%; height: 100%; }
  </style>

  <body>
    <style>
      body {
        font-family: Monospace;
        background-color: #000;
        color: #fff;
        margin: 0px;
        overflow: hidden;
      }
      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
      }
    </style>

    <div id="info">
      <p>Take photos of birds<br>
      left button to rotate the scene, scroll to zoom in/out</p>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js"
        }
      }
    </script>

    <script type="module">
      	import * as THREE from 'three';
		import { MTLLoader } from './jsm/loaders/MTLLoader.js';
		import { OBJLoader } from './jsm/loaders/OBJLoader.js';
		import { FirstPersonControls } from './jsm/controls/FirstPersonControls.js';

		var scene = new THREE.Scene();
		scene.background = new THREE.Color(0x8FBCD4); // Light blue background

		var ratio = window.innerWidth / window.innerHeight;
		var camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);
		camera.position.set(0, 10, 0);
		camera.lookAt(new THREE.Vector3(0, 10, 10));

		var renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.outputEncoding = THREE.sRGBEncoding;
		renderer.gammaOutput = true;
		renderer.gammaFactor = 2.2;
		renderer.physicallyCorrectLights = true;
		renderer.toneMapping = THREE.ACESFilmicToneMapping;
		renderer.toneMappingExposure = 1.0; // Adjust as needed
		
		//renderer.shadowMap.enabled = true;
		//renderer.shadowMap.type = THREE.PCFSoftShadowMap;


		document.body.appendChild(renderer.domElement);

		// Lighting
		var ambientLight = new THREE.AmbientLight(0xf7b9a1, 0.25);
		scene.add(ambientLight);

		var directionalLight1 = new THREE.DirectionalLight(0xEE9B31, 0.4);
		directionalLight1.position.set(0, 0.2, -1);
		directionalLight1.castShadow = true;
		scene.add(directionalLight1);

		var directionalLight2 = new THREE.DirectionalLight(0xFF4B2B,0.4);
		directionalLight2.position.set(0, 6, -10);
		directionalLight2.castShadow = true;
		scene.add(directionalLight2);

		var directionalLight3 = new THREE.DirectionalLight(0xFFDB25, 0.4);
		directionalLight3.position.set(0, 0.2, -10);
		directionalLight3.castShadow = true;
		scene.add(directionalLight3);

		//sky
		const vertexShader = `
			varying vec3 vWorldPosition;

			void main() {
				vec4 worldPosition = modelMatrix * vec4(position, 1.0);
				vWorldPosition = worldPosition.xyz;
				gl_Position = projectionMatrix * viewMatrix * worldPosition;
			}
		`;

		// Fragment Shader
		const fragmentShader = `
			varying vec3 vWorldPosition;

			void main() {
				float height = normalize(vWorldPosition).y;
				vec3 topColor = vec3(0.0, 0.3, 0.6); // Blue
				vec3 bottomColor = vec3(1.0, 0.65, 0.54); // Orange
				gl_FragColor = vec4(mix(bottomColor, topColor, max(height, 0.0)), 1.0);
			}
		`;

		// Create a large sphere geometry
		const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
		const skyMaterial = new THREE.ShaderMaterial({
			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			side: THREE.BackSide
		});

		const sky = new THREE.Mesh(skyGeometry, skyMaterial);
		scene.add(sky);

		//ground
		const loader = new THREE.TextureLoader();
		const grassTexture = loader.load('Assets/grass_texture.jpg');

		grassTexture.wrapS = THREE.RepeatWrapping;
		grassTexture.wrapT = THREE.RepeatWrapping;

		grassTexture.repeat.set(8, 8); // Slightly increase repeat to overlap

		grassTexture.minFilter = THREE.LinearMipMapLinearFilter;
		grassTexture.magFilter = THREE.LinearFilter;

		const groundGeometry = new THREE.PlaneGeometry(500, 500);
		const groundMaterial = new THREE.MeshStandardMaterial({
			normalMap: grassTexture,
			side: THREE.DoubleSide,
			color: 0x88cc54,
			roughness: 0.9,
			metalness: 0.0,
		});

		groundMaterial.normalScale = new THREE.Vector2(2, 2);

		const ground = new THREE.Mesh(groundGeometry, groundMaterial);
		ground.rotation.x = -Math.PI / 2;
		//ground.receiveShadow = true;
		scene.add(ground);

		// Global variables declared first
		const treeModels = [];
		const grassModels = [];
		const existingPositions = [];
		const playerPosition = { x: 0, z: 0 }; // Adjust this as needed

		function loadModel(path, mtlFile, objFile, callback) {
			var mtlLoader = new MTLLoader();
			mtlLoader.setPath(path);
			mtlLoader.load(mtlFile, function (materials) {
				materials.preload();
				var objLoader = new OBJLoader();
				objLoader.setMaterials(materials);
				objLoader.setPath(path);
				objLoader.load(objFile, function (originalObject) {
					callback(originalObject);
				});
			});
		}

		// Load the initial tree models
		loadModel('Assets/', 'Tree_1.mtl', 'Tree_1.obj', function (tree) {
			treeModels.push(tree);
			loadModel('Assets/', 'Tree_2.mtl', 'Tree_2.obj', function (tree) {
				treeModels.push(tree);
				loadModel('Assets/', 'Tree_3.mtl', 'Tree_3.obj', function (tree) {
					treeModels.push(tree);
					loadModel('Assets/', 'grass1_.mtl', 'grass1_.obj', function (grass) {
						grassModels.push(grass);
						loadModel('Assets/', 'grass2_.mtl', 'grass2_.obj', function (grass) {
							grassModels.push(grass);
							loadModel('Assets/', 'leaf_pile.mtl', 'leaf_pile.obj', function (grass) {
								grassModels.push(grass);
								grass.name = 'leaf pile';
								populateScene(); // Call the function after loading all models
							});
						});
					});
				});
			});
		});

		function addObject(models, minRadius, maxRadius, minDistance, scaleFactor = 4) {
			if (models.length === 0) {
				return; // No models loaded yet
			}

			let maxTries = 10;
			let posX, posZ;
			let isPositionValid = false;

			while (maxTries > 0 && !isPositionValid) {
				// Random angle between 0 and 180 degrees (in radians)
				const angle = Math.random() * Math.PI;
				// Random radius between minRadius and maxRadius units
				const radius = Math.random() * (maxRadius - minRadius) + minRadius;

				// Calculate the position using polar coordinates
				posX = playerPosition.x + radius * Math.cos(angle);
				posZ = playerPosition.z + radius * Math.sin(angle);

				isPositionValid = existingPositions.every(existingPos => {
					const distance = Math.sqrt(Math.pow(existingPos.x - posX, 2) + Math.pow(existingPos.z - posZ, 2));
					return distance > minDistance; // Set a suitable minimum distance
				});

				maxTries--;
			}

			if (!isPositionValid) {
				return; // Unable to find a valid position, so skip adding this object
			}

			// Randomly pick a model from the array
			var randomIndex = Math.floor(Math.random() * models.length);
			var originalObject = models[randomIndex];
			var obj = originalObject.clone();

			obj.position.set(posX, 0, posZ);
			obj.rotation.set(0, Math.random() * Math.PI * 2, 0);
			var scale;

			if (originalObject.name === "leaf pile") {
				scale = 2;
			}
			else {
				// Other models
				scale = (Math.random() * 0.5 + 0.5) * scaleFactor;
			}

			obj.scale.set(scale, scale, scale);
			scene.add(obj);

			// Add the new position to the list
			existingPositions.push({ x: posX, z: posZ });
		}

		// Populate the scene
		function populateScene() {
			// Add trees (further away)
			for (var i = 0; i < 500; i++) {
				addObject(treeModels, 100, 200, 20);
			}

			// Add grass (closer)
			for (var i = 0; i < 2000; i++) {
				addObject(grassModels, 10, 100, 2, 20);
			}
		}

		function onResize() {
			renderer.setSize(window.innerWidth, window.innerHeight);
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
		}

		const fpControls = new FirstPersonControls(camera, renderer.domElement);
		fpControls.movementSpeed = 1; // Set the movement speed as needed
		fpControls.lookSpeed = 0.1; // Set the look speed as needed

		function animate() {
			requestAnimationFrame(animate);
			fpControls.update(0.05); // Adjust the update rate for smooth animation

			renderer.render(scene, camera);
		}

		animate();

		window.addEventListener('resize', onResize);

		function updateLoop() {
			renderer.render(scene, camera);
			requestAnimationFrame(updateLoop);
		}

		requestAnimationFrame(updateLoop);


    </script>
  </body>
</html>